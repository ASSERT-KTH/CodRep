"Cluster stub compiler error: cluster configuration not supported for method : "

/*
 * Copyright (C) 2002-2003, Simon Nieuviarts
 */
/***
 * Jonathan: an Open Distributed Processing Environment
 * Copyright (C) 1999 France Telecom R&D
 * Copyright (C) 2002, Simon Nieuviarts
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Release: 2.0
 *
 * Contact: jonathan@objectweb.org
 *
 * Author: Kathleen Milsted
 *
 * with contributions from:
 *   Francois Horn
 *   Bruno Dumant
 *
 */
package org.objectweb.carol.cmi.compiler;

import java.util.Vector;
import java.io.File;

public class ClusterStubCompiler {

    private CompilerContext cmpCtx;
    private ClassContext classctx;
    private String stubClassName, stubFileName, stubFullFileName;
    private FileStream stubFile;
    private Vector remItfs;
    private MethodContext[] remMths;
    private int nbMths;

    private static String pre1 = "\t";
    private static String pre2 = pre1 + "\t";
    private static String pre3 = pre2 + "\t";
    private static String pre4 = pre3 + "\t";

    ClusterStubCompiler(CompilerContext cCtx) {
        cmpCtx = cCtx;
    }

    void run(String className, ClusterConf cconf) throws Exception {
        Utils.trace_header(cmpCtx);
        Utils.trace("generating a cluster stub class for " + className, cmpCtx);
        prepare(className);
        try {
            writeStub(cconf);
            if (cmpCtx.compile) {
                Utils.compileFile(cmpCtx, stubFullFileName);
            }
            if (!cmpCtx.keep) {
                Utils.deleteFile(cmpCtx, stubFullFileName);
            }
        } catch (Exception e) {
            if (!cmpCtx.keep)
                Utils.deleteFile(cmpCtx, stubFullFileName);
            throw e;
        }
    }

    void prepare(String className) throws Exception {
        // First, get all the relevant information for the class
        // In particular, getting the remote interfaces of the class
        // includes checking if the class directly implements
        // (in the implements clause of its declaration) at least one
        // remote interface. If not, an error will be thrown.
        classctx = new ClassContext(cmpCtx, className);
        remItfs = classctx.getRemoteInterfaces();
        remMths = classctx.getRemoteMethodContexts();
        nbMths = remMths.length;
        // prepare for generating the stub
        stubClassName = classctx.clName + "_Cluster";
        stubFileName = stubClassName + ".java";
        stubFullFileName = classctx.genDirName + File.separator + stubFileName;
        Utils.trace("stub source file is " + stubFullFileName, cmpCtx);
        stubFile = new FileStream(classctx.genDirName, stubFileName);
    }

    void writeStub(ClusterConf cconf) throws Exception {
        writeStubHeader();
        writeStubConstructors();
        writeStubMethods(cconf);
        writeStubFoot();
    }

    void writeStubHeader() throws Exception {
        stubFile.write(
            "/***\n"
                + " * Stub class generated by the cluster stub compiler "
                + CompilerContext.version
                + "\n"
                + " */\n\n");
        if (!classctx.inGlobalPkg) {
            Utils.trace("stub file: writing package declaration", cmpCtx);
            stubFile.write("package " + classctx.pkgName + ";\n");
            stubFile.write("\n");
        }
        Utils.trace("stub file: writing imports", cmpCtx);
        // imports
        stubFile.write("import org.objectweb.carol.cmi.ClusterStub;\n");
        stubFile.write("import java.rmi.Remote;\n");
        stubFile.write("import java.rmi.RemoteException;\n");

        stubFile.write("\n");
        String itfStr = "";
        for (int i = 0; i < remItfs.size(); i++) {
            if (((Class) remItfs.elementAt(i)).equals(java.rmi.Remote.class))
                continue;
            if (i > 0)
                itfStr = itfStr + ", ";
            itfStr = itfStr + ((Class) remItfs.elementAt(i)).getName();
        }
        Utils.trace("stub file: writing class declaration", cmpCtx);
        stubFile.write("/**\n");
        stubFile.write(" * Cluster stub for " + classctx.clName + "\n");
        stubFile.write(" */\n");
        stubFile.write(
            "public class "
                + stubClassName
                + "\n"
                + "extends ClusterStub\n"
                + "implements "
                + itfStr
                + " {\n");
        stubFile.write("\n");
    }

    void writeStubConstructors() {
        Utils.trace("stub file: writing constructors", cmpCtx);
        stubFile.write(pre1 + "// constructors\n");
        stubFile.write(pre1 + "public " + stubClassName + "() {}\n");
        stubFile.write(
            pre1
                + "public "
                + stubClassName
                + "(byte[] serverId, Remote stub) throws RemoteException {\n");
        stubFile.write(pre2 + "super(serverId, stub);\n");
        stubFile.write(pre1 + "}\n\n");
    }

    void writeStubMethods(ClusterConf cconf) throws Exception {
        MethodContext mthctx;
        ClusterMethodInfo cmi;
        for (int i = 0; i < nbMths; i++) {
            mthctx = (MethodContext) remMths[i];
            cmi = cconf.getMethodInfo(mthctx, classctx.clFullName);
            if (cmi == null) {
                System.err.println(
                    "Cluster stub compiler error: no configuration found for method :\n"
                        + mthctx.mth.toString());
                System.exit(1);
            }
            Utils.trace("stub file: writing method " + mthctx.mthName, cmpCtx);
            switch (cmi.getType()) {
                case ClusterMethodInfo.REDO_CHOICE_RETRY :
                    writeStubMethodRedoChoiceRetry(mthctx, cmi);
                    break;
                default :
                    System.err.println(
                        "Cluster stub compiler error: type not supported for method :\n"
                            + mthctx.mth.toString());
                    System.exit(1);
            }
        }
    }

    // XXX A cluster invoker would be a way to do piggybacking of load
    // information
    void writeClusterInvoker(MethodContext mthctx, ClusterMethodInfo cmi) {
    }

    void writeStubMethodRedoChoiceRetry(
        MethodContext mthctx,
        ClusterMethodInfo cmi) {
        // Write method header
        writeStubMethodHeader(mthctx);
        stubFile.write(" {\n");

        // Write method body
        stubFile.write(
            pre2
                + "org.objectweb.carol.cmi.StubListRandomChooser $chooser = ((ClusterStub)this).getRandomChooser();\n");
        stubFile.write(pre2 + mthctx.declItfName + " $stub;\n");
        stubFile.write(pre2 + "do {\n");
        stubFile.write(
            pre3 + "$stub = (" + mthctx.declItfName + ")$chooser.next();\n");
        stubFile.write(
            pre3
                + "if ($stub == null) throw new java.rmi.ConnectException(\"No server available\");\n");
        stubFile.write(pre3 + "try {\n");
        stubFile.write(
            pre4
                + "if (org.objectweb.carol.cmi.Trace.CSTUB) org.objectweb.carol.cmi.Trace.out(\"cluster invocation of "
                + mthctx.mthName
                + "()\");\n");
        if (mthctx.returnsVoid) {
            stubFile.write(pre4 + "$stub." + mthctx.mthName + "(");
        } else {
            stubFile.write(
                pre4
                    + mthctx.returnTypeName
                    + " $result = $stub."
                    + mthctx.mthName
                    + "(");
        }
        int nbParams = mthctx.nbParams;
        String[] paramNames = mthctx.getParamNames();
        for (int i = 0; i < nbParams; i++) {
            if (i > 0)
                stubFile.write(", ");
            stubFile.write(paramNames[i]);
        }
        stubFile.write(");\n");

        if (mthctx.returnsVoid)
            stubFile.write(pre4 + "return;\n");
        else
            stubFile.write(pre4 + "return $result;\n");

        stubFile.write(pre3 + "} catch (java.rmi.ConnectException e) {\n");
        stubFile.write(pre4 + "((ClusterStub)this).removeStub($stub);\n");
        stubFile.write(pre3 + "} catch (java.rmi.ConnectIOException e) {\n");
        stubFile.write(pre4 + "((ClusterStub)this).removeStub($stub);\n");
        stubFile.write(pre3 + "}\n");
        stubFile.write(pre2 + "} while (true);\n");

        // Write method end
        stubFile.write(pre1 + "}\n");
        stubFile.write("\n");
    }

    void writeStubMethodHeader(MethodContext mthctx) {
        stubFile.write(
            pre1
                + "public "
                + mthctx.returnTypeName
                + " "
                + mthctx.mthName
                + "(");
        String[] paramTypeNames = mthctx.getParamTypeNames();
        String[] paramNames = mthctx.getParamNames();
        for (int i = 0; i < paramTypeNames.length; i++) {
            if (i > 0)
                stubFile.write(", ");
            stubFile.write(paramTypeNames[i] + " " + paramNames[i]);
        }
        stubFile.write(")\n");
        String[] excTypeNames = mthctx.getExceptionTypeNames();
        int nbExcs = mthctx.nbExcs;
        stubFile.write(pre1 + "throws ");
        for (int i = 0; i < nbExcs; i++) {
            if (i != 0)
                stubFile.write(", ");
            stubFile.write(excTypeNames[i]);
        }
        if (!mthctx.declaresJavaRmiRemoteException) {
            if (nbExcs > 0)
                stubFile.write(", ");
            stubFile.write("java.rmi.RemoteException");
        }
    }

    void writeStubFoot() {
        stubFile.write("}\n");
        stubFile.close();
        Utils.trace("successfully generated stub source", cmpCtx);
    }

}