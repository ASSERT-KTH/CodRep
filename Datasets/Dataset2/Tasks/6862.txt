import org.tigris.scarab.util.word.Vocabulary;

package org.tigris.scarab.om;

// JDK classes
import java.util.*;
import java.sql.Connection;

// Turbine classes
import org.apache.turbine.om.*;
import org.apache.turbine.om.peer.BasePeer;
import org.apache.turbine.util.db.Criteria;
import org.apache.turbine.util.ObjectUtils;
import org.apache.turbine.services.resources.TurbineResources;
import org.apache.turbine.util.StringUtils;
import org.apache.turbine.util.RunData;
import org.apache.turbine.util.ParameterParser;
import org.apache.turbine.util.Log;
import org.apache.turbine.services.db.TurbineDB;
import org.apache.turbine.util.db.pool.DBConnection;
import org.apache.turbine.util.db.map.DatabaseMap;

import org.tigris.scarab.util.ScarabConstants;
import org.tigris.scarab.word.Vocabulary;

/** 
  * The skeleton for this class was autogenerated by Torque on:
  *
  * [Wed Feb 28 16:36:26 PST 2001]
  *
  * You should add additional methods to this class to meet the
  * application requirements.  This class will only be generated as
  * long as it does not already exist in the output directory.

  */
public class Issue 
    extends BaseIssue
    implements Persistent
{
    private Vocabulary vocabulary;

    public String getUniqueId() // throws Exception
    {
        return getIdPrefix() + getIdCount();
    }

    public String getFederatedId()
    {
        if ( getIdInstance() != null ) 
        {
            return getIdInstance() + getUniqueId();
        }
        return getUniqueId();
    }

    public void setFederatedId(String id)
    {
        FederatedId fid = new FederatedId(id);
        setIdInstance(fid.getInstance());
        setIdPrefix(fid.getInstance());
        setIdCount(fid.getCount());
    }
     
    public static class FederatedId
    {
        String instanceId;
        String prefix;
        int count;

        public FederatedId(String id)
        {
            int dash = id.indexOf('-');
            if ( dash > 0 ) 
            {
                instanceId = id.substring(0, dash);
                setUniqueId(id.substring(dash+1));
            }
            else 
            {
                setUniqueId(id);
            }
        }

        public void setUniqueId(String id)
        {
            // we could start at 1 here, if the spec says one char is 
            // required, will keep it safe for now.
            StringBuffer code = new StringBuffer(4);
            for ( int i=0; i<4; i++) 
            {
                char c = id.charAt(i);
                if ( c != '0' && c != '1' && c != '2' && c != '3' && c != '4'
                     && c != '5' && c != '6' && c != '7' && c!='8' && c!='9' )
                {
                    code.append(c);
                }
            }
            prefix = code.toString();
            count = Integer.parseInt( id.substring(code.length()) );
            
        }

        /**
         * Get the Prefix
         * @return String
         */
        public String getPrefix()
        {
            return prefix;
        }
        
        
        /**
         * Get the Count
         * @return int
         */
        public int getCount()
        {
            return count;
        }
        
        /**
         * Get the IdInstance
         * @return String
         */
        public String getInstance()
        {
            return instanceId;
        }
    }

    public static Issue getIssueById(String id)
    {
        FederatedId fid = new FederatedId(id);
        return getIssueById(fid);
    }

    public static Issue getIssueById(FederatedId fid)
    {
        Criteria crit = new Criteria(5)
            .add(IssuePeer.ID_PREFIX, fid.getPrefix())
            .add(IssuePeer.ID_COUNT, fid.getCount());

        if (  fid.getInstance() != null ) 
        {
            crit.add(IssuePeer.ID_INSTANCE, fid.getInstance());    
        }
        
        Issue issue = null;
        try
        {
            issue = (Issue)IssuePeer.doSelect(crit).get(0);
        }
        catch (Exception e) 
        {
            // return null
        }
        return issue;
    }

    /**
     * AttributeValues that are relevant to the issue's current module.
     * Empty AttributeValues that are relevant for the module, but have 
     * not been set for the issue are included.
     */
    public HashMap getModuleAttributeValuesMap() throws Exception
    {
        Criteria crit = new Criteria(2)
            .add(RModuleAttributePeer.ACTIVE, true);
        
        Attribute[] attributes = null;
        HashMap siaValuesMap = null;
        // this exception is getting lost 
        try{
        attributes = getModule().getAttributes(crit);
        siaValuesMap = getAttributeValuesMap();
        }catch (Exception e){e.printStackTrace();}

        HashMap map = new HashMap( (int)(1.25*attributes.length + 1) );

        for ( int i=0; i<attributes.length; i++ ) 
        {
            String key = attributes[i].getName().toUpperCase();

            if ( siaValuesMap.containsKey(key) ) 
            {
                map.put( key, siaValuesMap.get(key) );
            }
            else 
            {
                AttributeValue aval = AttributeValue
                    .getNewInstance(attributes[i], this);
                addAttributeValue(aval);
                map.put( key, aval );
            }
        }
        
        return map;
    }

    public AttributeValue getAttributeValue(Attribute attribute)
       throws Exception
    {
        Criteria crit = new Criteria(2)
            .add(AttributeValuePeer.DELETED, false)        
            .add(AttributeValuePeer.ATTRIBUTE_ID, attribute.getAttributeId());

        List avals = getAttributeValues(crit);
        AttributeValue aval = null;
        if ( avals.size() == 1 ) 
        {
            aval = (AttributeValue)avals.get(0);
        }
        
        return aval;
    }


    /**
     * AttributeValues in the order that is preferred for this module
     */
    public AttributeValue[] getOrderedModuleAttributeValues() throws Exception
    {
        
        Map values = getModuleAttributeValuesMap();

        Criteria crit = new Criteria(3)
            .add(RModuleAttributePeer.ACTIVE, true)
            .addOrderByColumn(RModuleAttributePeer.PREFERRED_ORDER);
        Attribute[] attributes = getModule().getAttributes(crit);

        return orderAttributeValues(values, attributes);
    }

    /**
     * AttributeValues that are set for this Issue in the order
     * that is preferred for this module
     */
    public AttributeValue[] getOrderedAttributeValues() throws Exception
    {        
        Map values = getAttributeValuesMap();

        Criteria crit = new Criteria(3)
            .add(RModuleAttributePeer.ACTIVE, true)
            .addOrderByColumn(RModuleAttributePeer.PREFERRED_ORDER);
        Attribute[] attributes = getModule().getAttributes(crit);

        return orderAttributeValues(values, attributes);
    }


    /**
     * Extract the AttributeValues from the Map according to the 
     * order in the Attribute[]
     */
    private AttributeValue[] orderAttributeValues(Map values, 
                                                  Attribute[] attributes) 
        throws Exception
    {
        AttributeValue[] orderedValues = new AttributeValue[values.size()];
        try{

        int i=0;
        for ( int j=0; j<attributes.length; j++ ) 
        {
            AttributeValue av = (AttributeValue) values
                .remove( attributes[j].getName().toUpperCase() );
            if ( av != null ) 
            {
                orderedValues[i++] = av;                
            }
        }
        Iterator iter = values.values().iterator();
        while ( iter.hasNext() ) 
        {
            orderedValues[i++] = (AttributeValue)iter.next();
        }

        }catch (Exception e){e.printStackTrace();}

        for ( int j=0; j<orderedValues.length; j++ ) 
        {
            
        }
        return orderedValues;
    }

    /*
    public static getMatchingIssues(AttributeValue[] avals, 
                                    boolean combineText)
    {

        Iterator iter = issue.getModuleAttributeValuesMap()
            .values().iterator();

        for ( int j=dedupeAttributes.length-1; j>=0; j-- ) 
        {
            while ( iter.hasNext() ) 
            {
                aval = (AttributeValue)iter.next();
                if ( aval.getAttribute().equals(dedupeAttributes[j])) 
                {
                    group = intake.get("AttributeValue", aval.getQueryKey());
                    group.setProperties(aval);
                        
                    for ( int k=matchingIssues.size()-1; k>=0; k--) 
                    {
                        Issue possibleMatch = (Issue)matchingIssues.get(k);
                        possibleMatch.getAttributeValue(dedupeAttributes[j]);
                    }
                        
                        
                        field.setRequired(true);
                        break;
                    }                    
                }
            }
        }
    */

    /**
     * AttributeValues that are set for this Issue
     */
    public HashMap getAttributeValuesMap() throws Exception
    {
        Criteria crit = new Criteria(2)
            .add(AttributeValuePeer.DELETED, false);        
        List siaValues = getAttributeValues(crit);
        HashMap map = new HashMap( (int)(1.25*siaValues.size() + 1) );
        for ( int i=0; i<siaValues.size(); i++ ) 
        {
            AttributeValue att = (AttributeValue) siaValues.get(i);
            String name = att.getAttribute().getName();
            map.put(name.toUpperCase(), att);
        }

        return map;
    }

    /**
     * AttributeValues that are set for this issue and
     * Empty AttributeValues that are relevant for the module, but have 
     * not been set for the issue are included.
     */
    public HashMap getAllAttributeValuesMap() throws Exception
    {
        Map moduleAtts = getModuleAttributeValuesMap();
        Map issueAtts = getAttributeValuesMap();
        HashMap allValuesMap = new HashMap( (int)(1.25*(moduleAtts.size() + 
                                            issueAtts.size())+1) );

        allValuesMap.putAll(moduleAtts);
        allValuesMap.putAll(issueAtts);
        return allValuesMap;
    }


    public boolean containsMinimumAttributeValues()
        throws Exception
    {
        Criteria crit = new Criteria(3)
            .add(RModuleAttributePeer.ACTIVE, true)        
            .add(RModuleAttributePeer.REQUIRED, true);        
        Attribute[] attributes = getModule().getAttributes(crit);
        //        Vector moduleAttributes = 
        //    getModule().getRModuleAttributes(crit);
        
        boolean result = true;
        Iterator i = getModuleAttributeValuesMap()
            .values().iterator();
        while (i.hasNext()) 
        {
            AttributeValue aval = (AttributeValue)i.next();
            
            if ( aval.getOptionId() == null && aval.getValue() == null ) 
            {
                for ( int j=attributes.length-1; j>=0; j-- ) 
                {
                    if ( aval.getAttribute().getPrimaryKey().equals(
                         attributes[j].getPrimaryKey() )) 
                    {
                        result = false;
                        break;
                    }                    
                }
                if ( !result ) 
                {
                    break;
                }
            }
        }

        return result;
    }       

    public void save()
        throws Exception
    {
        // remove unset AttributeValues before saving
        Criteria crit = new Criteria(2)
            .add(AttributeValuePeer.DELETED, false);        
        List attValues = getAttributeValues(crit);
        for ( int i=0; i<attValues.size(); i++ ) 
        {
            AttributeValue attVal = (AttributeValue) attValues.get(i);
            if ( attVal.getOptionId() == null && attVal.getValue() == null ) 
            {
                attValues.remove(i);
            }
        }

        // set the issue id
        if ( isNew() ) 
        {
            String prefix = getModule().getCode();

            /* thinking of keeping this in separate column
            String instanceCode = TurbineResources
                .getString(ScarabConstants.INSTANCE_NAME);
            if ( instanceCode != null && instanceCode.length() > 0 ) 
            {
                prefix = instanceCode + "-" + prefix;
            }
            */

            DatabaseMap dbMap = IssuePeer.getTableMap().getDatabaseMap();
            DBConnection dbCon = null;
            int numId = -1; 
            try
            {
                dbCon = TurbineDB.getConnection( dbMap.getName() );
                Connection con = dbCon.getConnection();
                numId = dbMap.getIDBroker().getIdAsInt(con, prefix);
            }
            finally
            {
                TurbineDB.releaseConnection(dbCon);
            }

            setIdPrefix(prefix);
            setIdCount(numId);
            
        }
        

        super.save();

        //now save vocabulary
        if (this.vocabulary!=null)
        {
            //should we remove old records first?
            for(Iterator i = this.vocabulary.getEntries().iterator();
                i.hasNext();)
            {
                Vocabulary.Entry entry = (Vocabulary.Entry)i.next();
                Word word;
                if (entry.isNew())
                {
                    word = new Word();
                    word.setWord(entry.getWord());
                    word.setIgnored(false);
                    word.setRating(
                        ScarabConstants.MAX_WORD_RATING /
                        entry.getCount());
                    word.save();
                    entry.setWordId(word.getWordId());
                }
                else
                {
                    word = WordPeer.retrieveByPK(entry.getWordId());
                }
                RIssueWord iw = new RIssueWord();
                iw.setIssueId(getIssueId());
                iw.setWordId(entry.getWordId());
                iw.setOccurences(entry.getCount());
                iw.setPosition(entry.getFirstPos());
                iw.save();
                word.updateRating();
            }
        }
    }

    /**
     *  sets vocabulary
     *
     */
    public void setVocabulary(Vocabulary voc)
    {
        this.vocabulary = voc;
    }

    /**
     *
     *
     */
    public Vocabulary getVocabulary()
    {
        return this.vocabulary;
    }

    /**
     * Performs a search over an issue's attribute values.
     *
     * @param keywords a <code>String[]</code> value
     * @param useAnd, an AND search if true, otherwise OR
     * @return a <code>List</code> value
     */
    public static List searchKeywords(String[] keywords, boolean useAnd)
        throws Exception
    {
        Criteria c = new Criteria(0);
        return IssuePeer.doSelect(c);
    }

}